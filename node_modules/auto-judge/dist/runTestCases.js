"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const util_1 = require("util");
const perf_hooks_1 = require("perf_hooks");
const ora = require("ora");
const name_1 = require("./constants/name");
const autoJudgeError_1 = require("./utils/autoJudgeError");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
const runProgram = (executeCommand, index) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const runCommand = `${executeCommand} < ${name_1.directoryName}/input_${index}.txt`;
        const runResultPromise = execAsync(runCommand, {
            signal: AbortSignal.timeout(2000),
        });
        const runResult = yield runResultPromise;
        return runResult.stdout;
    }
    catch (error) {
        if (error.name === 'AbortError')
            return 'timeout';
        throw new autoJudgeError_1.default('Runtime Error', error.toString());
    }
});
const runTestCases = (testCases, executeCommand, specificCase) => __awaiter(void 0, void 0, void 0, function* () {
    console.log();
    const spinner = ora('Running Test Case...').start();
    const testResults = [];
    const start = perf_hooks_1.performance.now();
    try {
        if (specificCase === undefined) {
            // run all test cases
            for (const [index, testCase] of testCases.entries()) {
                const start = perf_hooks_1.performance.now();
                const result = yield runProgram(executeCommand, index + 1);
                const end = perf_hooks_1.performance.now();
                const testResult = {
                    number: index + 1,
                    isSuccess: removeLeadingSpaces(result) ===
                        removeLeadingSpaces(testCase.output),
                    time: (end - start).toFixed(0),
                    expected: testCase.output,
                    received: result,
                };
                testResults.push(testResult);
            }
        }
        else {
            // run only specific test case
            const start = perf_hooks_1.performance.now();
            const result = yield runProgram(executeCommand, specificCase);
            const end = perf_hooks_1.performance.now();
            const testResult = {
                number: specificCase,
                isSuccess: removeLeadingSpaces(result) ===
                    removeLeadingSpaces(testCases[specificCase - 1].output),
                time: (end - start).toFixed(0),
                expected: testCases[specificCase - 1].output,
                received: result,
            };
            testResults.push(testResult);
        }
    }
    catch (error) {
        spinner.fail('Running Test Case Failed');
        throw error;
    }
    const end = perf_hooks_1.performance.now();
    const totalTime = ((end - start) / 1000).toFixed(3);
    const calculatedResult = calculateTestResults(testResults);
    const totalResult = {
        isAllSuccess: calculatedResult.isAllSuccess,
        totalTime,
        testResults,
        numberOfTest: {
            total: calculatedResult.numberOfTotalTest,
            passed: calculatedResult.numberOfPassedTest,
            failed: calculatedResult.numberOfFailedTest,
        },
    };
    spinner.succeed('Running Test Case Complete');
    return totalResult;
});
exports.default = runTestCases;
const calculateTestResults = (testResults) => {
    const isAllSuccess = testResults.every(testResult => testResult.isSuccess);
    const counts = testResults.reduce((counts, testResult) => {
        if (testResult.isSuccess) {
            counts.passedCount++;
        }
        else {
            counts.failedCount++;
        }
        return counts;
    }, { passedCount: 0, failedCount: 0 });
    return {
        isAllSuccess: isAllSuccess,
        numberOfTotalTest: testResults.length,
        numberOfPassedTest: counts.passedCount,
        numberOfFailedTest: counts.failedCount,
    };
};
const removeLeadingSpaces = (str) => {
    return str.replace(/ +\n/g, '\n');
};
